# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AccessToken {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  name: String!
}

input AddContextBlobInput {
  blobId: String!
  contextId: String!
}

input AddContextCategoryInput {
  categoryId: String!
  contextId: String!
  docs: [String!]
  type: ContextCategories!
}

input AddContextDocInput {
  contextId: String!
  docId: String!
}

input AddContextFileInput {
  contextId: String!
}

type AdminAllSharedLink {
  docId: String!
  docUpdatedAt: DateTime
  guestViews: SafeInt
  lastAccessedAt: DateTime
  lastUpdaterId: String
  publishedAt: DateTime
  shareUrl: String!
  title: String
  uniqueViews: SafeInt
  views: SafeInt
  workspaceId: String!
  workspaceOwnerId: String
}

type AdminAllSharedLinkEdge {
  cursor: String!
  node: AdminAllSharedLink!
}

input AdminAllSharedLinksFilterInput {
  analyticsWindowDays: Int = 28
  includeTotal: Boolean = false
  keyword: String
  orderBy: AdminSharedLinksOrder = UpdatedAtDesc
  updatedAfter: DateTime
  workspaceId: String
}

type AdminDashboard {
  blobStorageBytes: SafeInt!
  blobStorageHistory: [AdminDashboardValueDayPoint!]!
  copilotConversations: SafeInt!
  generatedAt: DateTime!
  periodPaidInvoices: Int!
  periodSignups: Int!
  registeredUsers: Int!
  revenueHistory: [AdminDashboardValueDayPoint!]!
  revenuePaidCents: SafeInt!
  revenueWindow: TimeWindow!
  signupHistory: [AdminDashboardValueDayPoint!]!
  signupWindow: TimeWindow!
  storageWindow: TimeWindow!
  syncActiveUsers: Int!
  syncActiveUsersTimeline: [AdminDashboardMinutePoint!]!
  syncWindow: TimeWindow!
  topSharedLinks: [AdminSharedLinkTopItem!]!
  topSharedLinksWindow: TimeWindow!
  totalUsers: Int!
  workspaceStorageBytes: SafeInt!
  workspaceStorageHistory: [AdminDashboardValueDayPoint!]!
}

input AdminDashboardInput {
  sharedLinkWindowDays: Int = 28
  storageHistoryDays: Int = 30
  syncHistoryHours: Int = 48
  timezone: String = "UTC"
}

type AdminDashboardMinutePoint {
  activeUsers: Int!
  minute: DateTime!
}

type AdminDashboardValueDayPoint {
  date: DateTime!
  value: SafeInt!
}

input AdminPayoutActionInput {
  note: String
  payoutId: String!
}

type AdminSharedLinkTopItem {
  docId: String!
  guestViews: SafeInt!
  lastAccessedAt: DateTime
  publishedAt: DateTime
  shareUrl: String!
  title: String
  uniqueViews: SafeInt!
  views: SafeInt!
  workspaceId: String!
}

enum AdminSharedLinksOrder {
  PublishedAtDesc
  UpdatedAtDesc
  ViewsDesc
}

input AdminUpdateAffiliateInput {
  levelOneRateBps: Int
  levelTwoRateBps: Int
  payoutEmail: String
  status: String
  userId: String!
}

input AdminUpdateWorkspaceInput {
  avatarKey: String
  enableAi: Boolean
  enableDocEmbedding: Boolean
  enableSharing: Boolean
  enableUrlPreview: Boolean
  features: [FeatureType!]
  id: String!
  name: String
  public: Boolean
}

type AdminWorkspace {
  avatarKey: String
  blobCount: Int!
  blobSize: SafeInt!
  createdAt: DateTime!
  enableAi: Boolean!
  enableDocEmbedding: Boolean!
  enableSharing: Boolean!
  enableUrlPreview: Boolean!
  features: [FeatureType!]!
  id: String!
  memberCount: Int!

  """Members of workspace"""
  members(query: String, skip: Int, take: Int): [AdminWorkspaceMember!]!
  name: String
  owner: WorkspaceUserType
  public: Boolean!
  publicPageCount: Int!
  sharedLinks: [AdminWorkspaceSharedLink!]!
  snapshotCount: Int!
  snapshotSize: SafeInt!
}

type AdminWorkspaceMember {
  avatarUrl: String
  email: String!
  id: String!
  name: String!
  role: Permission!
  status: WorkspaceMemberStatus!
}

type AdminWorkspaceSharedLink {
  docId: String!
  publishedAt: DateTime
  title: String
}

enum AdminWorkspaceSort {
  BlobCount
  BlobSize
  CreatedAt
  MemberCount
  PublicPageCount
  SnapshotCount
  SnapshotSize
}

type AffiliateAdminListItemType {
  createdAt: DateTime!
  email: String!
  name: String!
  paidCents: Int!
  pendingCents: Int!
  referralCode: String!
  referrals: Int!
  status: String!
  taxInfoComplete: Boolean!
  termsAcceptedAt: DateTime
  userId: String!
}

type AffiliateAdminOverviewType {
  activeAffiliates: Int!
  paidCommissionsCents: Int!
  paidOutCents: Int!
  pendingCommissionsCents: Int!
  periodReferralCount: Int!
  reversedCommissionsCents: Int!
  totalReferralCount: Int!
}

type AffiliateAdminPayoutDetailType {
  events: [AffiliateComplianceEventType!]!
  items: [AffiliatePayoutItemType!]!
  payout: AffiliatePayoutType!
}

type AffiliateComplianceEventType {
  actorUserId: String
  affiliateUserId: String!
  createdAt: DateTime!
  eventType: String!
  id: String!
  message: String!
  metadata: JSONObject
  payoutId: String
  severity: String!
}

type AffiliateDashboardType {
  activeReferralCount: Int!
  hierarchy: [AffiliateHierarchyNodeType!]!
  paidCommissionsCents: Int!
  payouts: [AffiliatePayoutType!]!
  pendingCommissionsCents: Int!
  profile: AffiliateProfileType!
  recentLedgerEntries: [AffiliateLedgerEntryType!]!
  recentReferrals: [AffiliateReferralType!]!
  referralCount: Int!
}

type AffiliateHierarchyNodeType {
  activeReferralCount: Int!
  children: [AffiliateHierarchyNodeType!]!
  directReferralCount: Int!
  email: String
  joinedAt: DateTime!
  level: Int!
  name: String
  referralCode: String!
  totalCommissionsCents: Int!
  userId: String!
}

type AffiliateLedgerEntryType {
  amountCents: Int!
  availableAt: DateTime!
  createdAt: DateTime!
  currency: String!
  id: String!
  invoiceId: String
  level: Int!
  reason: String
  referredUserId: String!
  status: String!
}

type AffiliatePayoutItemType {
  amountCents: Int!
  createdAt: DateTime!
  currency: String!
  invoiceId: String
  ledgerId: String!
  level: Int!
  referredUserId: String!
  taxInfoComplete: Boolean!
  termsAcceptedAt: DateTime
}

type AffiliatePayoutType {
  createdAt: DateTime!
  currency: String!
  id: String!
  paidAt: DateTime
  periodEnd: DateTime!
  periodStart: DateTime!
  status: String!
  stripeTransferId: String
  stripeTransferStatus: String
  totalCents: Int!
}

type AffiliateProfileType {
  createdAt: DateTime!
  levelOneRateBps: Int!
  levelTwoRateBps: Int!
  parentAffiliateUserId: String
  payoutEmail: String
  referralCode: String!
  status: String!
  stripeConnectAccountId: String
  stripeConnectCountry: String
  stripeDetailsSubmitted: Boolean!
  stripePayoutsEnabled: Boolean!
  stripeRequirements: JSONObject
  taxInfo: JSONObject
  termsAcceptedAt: DateTime
  termsVersion: String
  updatedAt: DateTime!
  userId: String!
}

type AffiliateReferralType {
  activatedAt: DateTime
  campaign: String
  createdAt: DateTime!
  id: String!
  referralCode: String!
  referredEmail: String
  referredName: String
  referredUserId: String!
  source: String
}

type AggregateBucketHitsObjectType {
  nodes: [SearchNodeObjectType!]!
}

type AggregateBucketObjectType {
  count: Int!

  """The hits object"""
  hits: AggregateBucketHitsObjectType!
  key: String!
}

input AggregateHitsOptions {
  fields: [String!]!
  highlights: [SearchHighlight!]
  pagination: AggregateHitsPagination
}

input AggregateHitsPagination {
  limit: Int
  skip: Int
}

input AggregateInput {
  field: String!
  options: AggregateOptions!
  query: SearchQuery!
  table: SearchTable!
}

input AggregateOptions {
  hits: AggregateHitsOptions!
  pagination: SearchPagination
}

type AggregateResultObjectType {
  buckets: [AggregateBucketObjectType!]!
  pagination: SearchResultPagination!
}

enum AiJobStatus {
  claimed
  failed
  finished
  pending
  running
}

type AlreadyInSpaceDataType {
  spaceId: String!
}

type AppConfigValidateResult {
  error: String
  key: String!
  module: String!
  valid: Boolean!
  value: JSON!
}

type BlobNotFoundDataType {
  blobId: String!
  spaceId: String!
}

type BlobUploadInit {
  alreadyUploaded: Boolean
  blobKey: String!
  expiresAt: DateTime
  headers: JSONObject
  method: BlobUploadMethod!
  partSize: Int
  uploadId: String
  uploadUrl: String
  uploadedParts: [BlobUploadedPart!]
}

"""Blob upload method"""
enum BlobUploadMethod {
  GRAPHQL
  MULTIPART
  PRESIGNED
}

type BlobUploadPart {
  expiresAt: DateTime
  headers: JSONObject
  uploadUrl: String!
}

input BlobUploadPartInput {
  etag: String!
  partNumber: Int!
}

type BlobUploadedPart {
  etag: String!
  partNumber: Int!
}

type CalendarAccountObjectType {
  calendars: [CalendarSubscriptionObjectType!]!
  calendarsCount: Int!
  createdAt: DateTime!
  displayName: String
  email: String
  id: String!
  lastError: String
  provider: CalendarProviderType!
  providerAccountId: String!
  refreshIntervalMinutes: Int!
  status: String!
  updatedAt: DateTime!
}

type CalendarCalDAVProviderPresetObjectType {
  docsUrl: String
  id: String!
  label: String!
  requiresAppPassword: Boolean
}

type CalendarEventObjectType {
  allDay: Boolean!
  description: String
  endAtUtc: DateTime!
  externalEventId: String!
  id: String!
  location: String
  originalTimezone: String
  recurrenceId: String
  startAtUtc: DateTime!
  status: String
  subscriptionId: String!
  title: String
}

type CalendarProviderRequestErrorDataType {
  message: String!
  status: Int!
}

enum CalendarProviderType {
  CalDAV
  Google
}

type CalendarSubscriptionObjectType {
  accountId: String!
  color: String
  displayName: String
  enabled: Boolean!
  externalCalendarId: String!
  id: String!
  lastSyncAt: DateTime
  provider: CalendarProviderType!
  timezone: String
}

enum ChatHistoryOrder {
  asc
  desc
}

type ChatMessage {
  attachments: [String!]
  content: String!
  createdAt: DateTime!
  id: ID
  params: JSON
  role: String!
  streamObjects: [StreamObject!]
}

"""Comment change action"""
enum CommentChangeAction {
  delete
  update
}

type CommentChangeObjectType {
  """The action of the comment change"""
  action: CommentChangeAction!
  commentId: ID
  id: ID!

  """
  The item of the comment or reply, different types have different fields, see UnionCommentObjectType
  """
  item: JSONObject!
}

type CommentChangeObjectTypeEdge {
  cursor: String!
  node: CommentChangeObjectType!
}

input CommentCreateInput {
  content: JSONObject!
  docId: ID!
  docMode: DocMode!
  docTitle: String!

  """
  The mention user ids, if not provided, the comment will not be mentioned
  """
  mentions: [String!]
  workspaceId: ID!
}

type CommentObjectType {
  """The content of the comment"""
  content: JSONObject!

  """The created at time of the comment"""
  createdAt: DateTime!
  id: ID!

  """The replies of the comment"""
  replies: [ReplyObjectType!]!

  """Whether the comment is resolved"""
  resolved: Boolean!

  """The updated at time of the comment"""
  updatedAt: DateTime!

  """The user who created the comment"""
  user: PublicUserType!
}

type CommentObjectTypeEdge {
  cursor: String!
  node: CommentObjectType!
}

input CommentResolveInput {
  id: ID!

  """Whether the comment is resolved"""
  resolved: Boolean!
}

input CommentUpdateInput {
  content: JSONObject!
  id: ID!
}

enum ContextCategories {
  Collection
  Tag
}

enum ContextEmbedStatus {
  failed
  finished
  processing
}

type ContextMatchedDocChunk {
  chunk: SafeInt!
  content: String!
  distance: Float
  docId: String!
}

type ContextMatchedFileChunk {
  blobId: String!
  chunk: SafeInt!
  content: String!
  distance: Float
  fileId: String!
  mimeType: String!
  name: String!
}

type ContextWorkspaceEmbeddingStatus {
  embedded: SafeInt!
  total: SafeInt!
}

type Copilot {
  audioTranscription(blobId: String, jobId: String): TranscriptionResultType
  chats(docId: String, options: QueryChatHistoriesInput, pagination: PaginationInput!): PaginatedCopilotHistoriesType!

  """Get the context list of a session"""
  contexts(contextId: String, sessionId: String): [CopilotContext!]!
  histories(docId: String, options: QueryChatHistoriesInput): [CopilotHistories!]! @deprecated(reason: "use `chats` instead")

  """List available models for a prompt, with human-readable names"""
  models(promptName: String!): CopilotModelsType!

  """Get the quota of the user in the workspace"""
  quota: CopilotQuota!

  """Get the session by id"""
  session(sessionId: String!): CopilotSessionType!

  """Get the session list in the workspace"""
  sessions(docId: String, options: QueryChatSessionsInput): [CopilotSessionType!]! @deprecated(reason: "use `chats` instead")
  workspaceId: ID
}

type CopilotContext {
  """list blobs in context"""
  blobs: [CopilotContextBlob!]!

  """list collections in context"""
  collections: [CopilotContextCategory!]!

  """list files in context"""
  docs: [CopilotContextDoc!]!

  """list files in context"""
  files: [CopilotContextFile!]!
  id: ID

  """match file in context"""
  matchFiles(content: String!, limit: SafeInt, scopedThreshold: Float, threshold: Float): [ContextMatchedFileChunk!]!

  """match workspace docs"""
  matchWorkspaceDocs(content: String!, limit: SafeInt, scopedThreshold: Float, threshold: Float): [ContextMatchedDocChunk!]!

  """list tags in context"""
  tags: [CopilotContextCategory!]!
  workspaceId: String!
}

type CopilotContextBlob {
  createdAt: SafeInt!
  id: ID!
  status: ContextEmbedStatus
}

type CopilotContextCategory {
  createdAt: SafeInt!
  docs: [CopilotContextDoc!]!
  id: ID!
  type: ContextCategories!
}

type CopilotContextDoc {
  createdAt: SafeInt!
  id: ID!
  status: ContextEmbedStatus
}

type CopilotContextFile {
  blobId: String!
  chunkSize: SafeInt!
  createdAt: SafeInt!
  error: String
  id: ID!
  mimeType: String!
  name: String!
  status: ContextEmbedStatus!
}

type CopilotContextFileNotSupportedDataType {
  fileName: String!
  message: String!
}

type CopilotDocNotFoundDataType {
  docId: String!
}

type CopilotFailedToAddWorkspaceFileEmbeddingDataType {
  message: String!
}

type CopilotFailedToGenerateEmbeddingDataType {
  message: String!
  provider: String!
}

type CopilotFailedToMatchContextDataType {
  content: String!
  contextId: String!
  message: String!
}

type CopilotFailedToMatchGlobalContextDataType {
  content: String!
  message: String!
  workspaceId: String!
}

type CopilotFailedToModifyContextDataType {
  contextId: String!
  message: String!
}

type CopilotHistories {
  """An mark identifying which view to use to display the session"""
  action: String
  createdAt: DateTime!
  docId: String
  messages: [ChatMessage!]!
  model: String!
  optionalModels: [String!]!
  parentSessionId: String
  pinned: Boolean!
  promptName: String!
  sessionId: String!
  title: String

  """The number of tokens used in the session"""
  tokens: Int!
  updatedAt: DateTime!
  workspaceId: String!
}

type CopilotHistoriesTypeEdge {
  cursor: String!
  node: CopilotHistories!
}

type CopilotInvalidContextDataType {
  contextId: String!
}

type CopilotMessageNotFoundDataType {
  messageId: String!
}

type CopilotModelType {
  id: String!
  name: String!
}

type CopilotModelsType {
  defaultModel: String!
  optionalModels: [CopilotModelType!]!
  proModels: [CopilotModelType!]!
}

input CopilotPromptConfigInput {
  frequencyPenalty: Float
  presencePenalty: Float
  temperature: Float
  topP: Float
}

type CopilotPromptConfigType {
  frequencyPenalty: Float
  presencePenalty: Float
  temperature: Float
  topP: Float
}

input CopilotPromptMessageInput {
  content: String!
  params: JSON
  role: CopilotPromptMessageRole!
}

enum CopilotPromptMessageRole {
  assistant
  system
  user
}

type CopilotPromptMessageType {
  content: String!
  params: JSON
  role: CopilotPromptMessageRole!
}

type CopilotPromptNotFoundDataType {
  name: String!
}

type CopilotPromptType {
  action: String
  config: CopilotPromptConfigType
  messages: [CopilotPromptMessageType!]!
  model: String!
  name: String!
}

type CopilotProviderNotSupportedDataType {
  kind: String!
  provider: String!
}

type CopilotProviderSideErrorDataType {
  kind: String!
  message: String!
  provider: String!
}

type CopilotQuota {
  limit: SafeInt
  used: SafeInt!
}

type CopilotSessionType {
  docId: String
  id: ID!
  model: String!
  optionalModels: [String!]!
  parentSessionId: ID
  pinned: Boolean!
  promptName: String!
  title: String
}

type CopilotWorkspaceConfig {
  allIgnoredDocs: [CopilotWorkspaceIgnoredDoc!]!
  files(pagination: PaginationInput!): PaginatedCopilotWorkspaceFileType!
  ignoredDocs(pagination: PaginationInput!): PaginatedIgnoredDocsType!
  workspaceId: String!
}

type CopilotWorkspaceFile {
  blobId: String!
  createdAt: DateTime!
  fileId: String!
  fileName: String!
  mimeType: String!
  size: SafeInt!
  workspaceId: String!
}

type CopilotWorkspaceFileTypeEdge {
  cursor: String!
  node: CopilotWorkspaceFile!
}

type CopilotWorkspaceIgnoredDoc {
  createdAt: DateTime!
  createdBy: String
  createdByAvatar: String
  docCreatedAt: DateTime
  docId: String!
  docUpdatedAt: DateTime
  title: String
  updatedBy: String
}

type CopilotWorkspaceIgnoredDocTypeEdge {
  cursor: String!
  node: CopilotWorkspaceIgnoredDoc!
}

input CreateChatMessageInput {
  attachments: [String!]
  blob: Upload
  blobs: [Upload!]
  content: String
  params: JSON
  sessionId: String!
}

input CreateChatSessionInput {
  docId: String
  pinned: Boolean

  """The prompt name to use for the session"""
  promptName: String!

  """true by default, compliant for old version"""
  reuseLatestChat: Boolean
  workspaceId: String!
}

input CreateCheckoutSessionInput {
  args: JSONObject
  coupon: String
  idempotencyKey: String
  plan: SubscriptionPlan = Pro
  recurring: SubscriptionRecurring = Yearly
  successCallbackLink: String!
  variant: SubscriptionVariant
}

input CreateCopilotPromptInput {
  action: String
  config: CopilotPromptConfigInput
  messages: [CopilotPromptMessageInput!]!
  model: String!
  name: String!
}

input CreateOrganizationInput {
  """Organization name"""
  name: String!

  """Organization slug (URL-friendly identifier)"""
  slug: String!
}

input CreateUserInput {
  email: String!
  name: String
  password: String
}

type CredentialsRequirementType {
  password: PasswordLimitsType!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DeleteAccount {
  success: Boolean!
}

input DeleteSessionInput {
  docId: String
  sessionIds: [String!]!
  workspaceId: String!
}

type DocActionDeniedDataType {
  action: String!
  docId: String!
  spaceId: String!
}

type DocHistoryNotFoundDataType {
  docId: String!
  spaceId: String!
  timestamp: Int!
}

type DocHistoryType {
  editor: EditorType
  id: String!
  timestamp: DateTime!
  workspaceId: String!
}

type DocMemberLastAccess {
  lastAccessedAt: DateTime!
  lastDocId: String
  user: PublicUserType!
}

type DocMemberLastAccessEdge {
  cursor: String!
  node: DocMemberLastAccess!
}

"""Doc mode"""
enum DocMode {
  edgeless
  page
}

type DocNotFoundDataType {
  docId: String!
  spaceId: String!
}

type DocPageAnalytics {
  generatedAt: DateTime!
  series: [DocPageAnalyticsPoint!]!
  summary: DocPageAnalyticsSummary!
  window: TimeWindow!
}

input DocPageAnalyticsInput {
  timezone: String = "UTC"
  windowDays: Int = 28
}

type DocPageAnalyticsPoint {
  date: DateTime!
  guestViews: SafeInt!
  totalViews: SafeInt!
  uniqueViews: SafeInt!
}

type DocPageAnalyticsSummary {
  guestViews: SafeInt!
  lastAccessedAt: DateTime
  totalViews: SafeInt!
  uniqueViews: SafeInt!
}

type DocPermissions {
  Doc_Comments_Create: Boolean!
  Doc_Comments_Delete: Boolean!
  Doc_Comments_Read: Boolean!
  Doc_Comments_Resolve: Boolean!
  Doc_Copy: Boolean!
  Doc_Delete: Boolean!
  Doc_Duplicate: Boolean!
  Doc_Properties_Read: Boolean!
  Doc_Properties_Update: Boolean!
  Doc_Publish: Boolean!
  Doc_Read: Boolean!
  Doc_Restore: Boolean!
  Doc_TransferOwner: Boolean!
  Doc_Trash: Boolean!
  Doc_Update: Boolean!
  Doc_Users_Manage: Boolean!
  Doc_Users_Read: Boolean!
}

"""User permission in doc"""
enum DocRole {
  Commenter
  Editor
  External
  Manager
  None
  Owner
  Reader
}

type DocType {
  """Doc page analytics in a time window"""
  analytics(input: DocPageAnalyticsInput): DocPageAnalytics!
  createdAt: DateTime

  """Doc create user"""
  createdBy: PublicUserType
  creatorId: String
  defaultRole: DocRole!

  """paginated doc granted users list"""
  grantedUsersList(pagination: PaginationInput!): PaginatedGrantedDocUserType!
  id: String!

  """Paginated last accessed members of the current doc"""
  lastAccessedMembers(includeTotal: Boolean = false, pagination: PaginationInput!, query: String): PaginatedDocMemberLastAccess!

  """Doc last updated user"""
  lastUpdatedBy: PublicUserType
  lastUpdaterId: String

  """Doc metadata"""
  meta: WorkspaceDocMeta!
  mode: PublicDocMode!
  permissions: DocPermissions!
  public: Boolean!
  summary: String
  title: String
  updatedAt: DateTime
  workspaceId: String!
}

type DocTypeEdge {
  cursor: String!
  node: DocType!
}

type DocUpdateBlockedDataType {
  docId: String!
  spaceId: String!
}

type EditorType {
  avatarUrl: String
  name: String!
}

union ErrorDataUnion = AlreadyInSpaceDataType | BlobNotFoundDataType | CalendarProviderRequestErrorDataType | CopilotContextFileNotSupportedDataType | CopilotDocNotFoundDataType | CopilotFailedToAddWorkspaceFileEmbeddingDataType | CopilotFailedToGenerateEmbeddingDataType | CopilotFailedToMatchContextDataType | CopilotFailedToMatchGlobalContextDataType | CopilotFailedToModifyContextDataType | CopilotInvalidContextDataType | CopilotMessageNotFoundDataType | CopilotPromptNotFoundDataType | CopilotProviderNotSupportedDataType | CopilotProviderSideErrorDataType | DocActionDeniedDataType | DocHistoryNotFoundDataType | DocNotFoundDataType | DocUpdateBlockedDataType | ExpectToGrantDocUserRolesDataType | ExpectToRevokeDocUserRolesDataType | ExpectToUpdateDocUserRoleDataType | GraphqlBadRequestDataType | HttpRequestErrorDataType | InvalidAppConfigDataType | InvalidAppConfigInputDataType | InvalidEmailDataType | InvalidHistoryTimestampDataType | InvalidIndexerInputDataType | InvalidLicenseToActivateDataType | InvalidLicenseUpdateParamsDataType | InvalidOauthCallbackCodeDataType | InvalidOauthResponseDataType | InvalidPasswordLengthDataType | InvalidRuntimeConfigTypeDataType | InvalidSearchProviderRequestDataType | MemberNotFoundInSpaceDataType | MentionUserDocAccessDeniedDataType | MissingOauthQueryParameterDataType | NoCopilotProviderAvailableDataType | NoMoreSeatDataType | NotInSpaceDataType | QueryTooLongDataType | ResponseTooLargeErrorDataType | RuntimeConfigNotFoundDataType | SameSubscriptionRecurringDataType | SpaceAccessDeniedDataType | SpaceNotFoundDataType | SpaceOwnerNotFoundDataType | SpaceShouldHaveOnlyOneOwnerDataType | SsrfBlockedErrorDataType | SubscriptionAlreadyExistsDataType | SubscriptionNotExistsDataType | SubscriptionPlanNotFoundDataType | UnknownOauthProviderDataType | UnsupportedClientVersionDataType | UnsupportedSubscriptionPlanDataType | ValidationErrorDataType | VersionRejectedDataType | WorkspacePermissionNotFoundDataType | WrongSignInCredentialsDataType

enum ErrorNames {
  ACCESS_DENIED
  ACTION_FORBIDDEN
  ACTION_FORBIDDEN_ON_NON_TEAM_WORKSPACE
  ALREADY_IN_SPACE
  AUTHENTICATION_REQUIRED
  BAD_REQUEST
  BLOB_INVALID
  BLOB_NOT_FOUND
  BLOB_QUOTA_EXCEEDED
  CALENDAR_PROVIDER_REQUEST_ERROR
  CANNOT_DELETE_ACCOUNT_WITH_OWNED_TEAM_WORKSPACE
  CANNOT_DELETE_ALL_ADMIN_ACCOUNT
  CANNOT_DELETE_OWN_ACCOUNT
  CANT_UPDATE_ONETIME_PAYMENT_SUBSCRIPTION
  CAN_NOT_BATCH_GRANT_DOC_OWNER_PERMISSIONS
  CAN_NOT_REVOKE_YOURSELF
  CAPTCHA_VERIFICATION_FAILED
  COMMENT_ATTACHMENT_NOT_FOUND
  COMMENT_ATTACHMENT_QUOTA_EXCEEDED
  COMMENT_NOT_FOUND
  COPILOT_ACTION_TAKEN
  COPILOT_CONTEXT_FILE_NOT_SUPPORTED
  COPILOT_DOCS_NOT_FOUND
  COPILOT_DOC_NOT_FOUND
  COPILOT_EMBEDDING_DISABLED
  COPILOT_EMBEDDING_UNAVAILABLE
  COPILOT_FAILED_TO_ADD_WORKSPACE_FILE_EMBEDDING
  COPILOT_FAILED_TO_CREATE_MESSAGE
  COPILOT_FAILED_TO_GENERATE_EMBEDDING
  COPILOT_FAILED_TO_GENERATE_TEXT
  COPILOT_FAILED_TO_MATCH_CONTEXT
  COPILOT_FAILED_TO_MATCH_GLOBAL_CONTEXT
  COPILOT_FAILED_TO_MODIFY_CONTEXT
  COPILOT_INVALID_CONTEXT
  COPILOT_MESSAGE_NOT_FOUND
  COPILOT_PROMPT_INVALID
  COPILOT_PROMPT_NOT_FOUND
  COPILOT_PROVIDER_NOT_SUPPORTED
  COPILOT_PROVIDER_SIDE_ERROR
  COPILOT_QUOTA_EXCEEDED
  COPILOT_SESSION_DELETED
  COPILOT_SESSION_INVALID_INPUT
  COPILOT_SESSION_NOT_FOUND
  COPILOT_TRANSCRIPTION_AUDIO_NOT_PROVIDED
  COPILOT_TRANSCRIPTION_JOB_EXISTS
  COPILOT_TRANSCRIPTION_JOB_NOT_FOUND
  CUSTOMER_PORTAL_CREATE_FAILED
  DOC_ACTION_DENIED
  DOC_DEFAULT_ROLE_CAN_NOT_BE_OWNER
  DOC_HISTORY_NOT_FOUND
  DOC_IS_NOT_PUBLIC
  DOC_NOT_FOUND
  DOC_UPDATE_BLOCKED
  EMAIL_ALREADY_USED
  EMAIL_SERVICE_NOT_CONFIGURED
  EMAIL_TOKEN_NOT_FOUND
  EMAIL_VERIFICATION_REQUIRED
  EXPECT_TO_GRANT_DOC_USER_ROLES
  EXPECT_TO_PUBLISH_DOC
  EXPECT_TO_REVOKE_DOC_USER_ROLES
  EXPECT_TO_REVOKE_PUBLIC_DOC
  EXPECT_TO_UPDATE_DOC_USER_ROLE
  FAILED_TO_CHECKOUT
  FAILED_TO_SAVE_UPDATES
  FAILED_TO_UPSERT_SNAPSHOT
  GRAPHQL_BAD_REQUEST
  HTTP_REQUEST_ERROR
  INTERNAL_SERVER_ERROR
  INVALID_APP_CONFIG
  INVALID_APP_CONFIG_INPUT
  INVALID_AUTH_STATE
  INVALID_CHECKOUT_PARAMETERS
  INVALID_EMAIL
  INVALID_EMAIL_TOKEN
  INVALID_HISTORY_TIMESTAMP
  INVALID_INDEXER_INPUT
  INVALID_INVITATION
  INVALID_LICENSE_SESSION_ID
  INVALID_LICENSE_TO_ACTIVATE
  INVALID_LICENSE_UPDATE_PARAMS
  INVALID_OAUTH_CALLBACK_CODE
  INVALID_OAUTH_CALLBACK_STATE
  INVALID_OAUTH_RESPONSE
  INVALID_PASSWORD_LENGTH
  INVALID_RUNTIME_CONFIG_TYPE
  INVALID_SEARCH_PROVIDER_REQUEST
  INVALID_SUBSCRIPTION_PARAMETERS
  LICENSE_EXPIRED
  LICENSE_NOT_FOUND
  LICENSE_REVEALED
  LINK_EXPIRED
  MAILER_SERVICE_IS_NOT_CONFIGURED
  MANAGED_BY_APP_STORE_OR_PLAY
  MEMBER_NOT_FOUND_IN_SPACE
  MEMBER_QUOTA_EXCEEDED
  MENTION_USER_DOC_ACCESS_DENIED
  MENTION_USER_ONESELF_DENIED
  MISSING_OAUTH_QUERY_PARAMETER
  NETWORK_ERROR
  NEW_OWNER_IS_NOT_ACTIVE_MEMBER
  NOTIFICATION_NOT_FOUND
  NOT_FOUND
  NOT_IN_SPACE
  NO_COPILOT_PROVIDER_AVAILABLE
  NO_MORE_SEAT
  OAUTH_ACCOUNT_ALREADY_CONNECTED
  OAUTH_STATE_EXPIRED
  OWNER_CAN_NOT_LEAVE_WORKSPACE
  PASSWORD_REQUIRED
  QUERY_TOO_LONG
  REPLY_NOT_FOUND
  RESPONSE_TOO_LARGE_ERROR
  RUNTIME_CONFIG_NOT_FOUND
  SAME_EMAIL_PROVIDED
  SAME_SUBSCRIPTION_RECURRING
  SEARCH_PROVIDER_NOT_FOUND
  SIGN_UP_FORBIDDEN
  SPACE_ACCESS_DENIED
  SPACE_NOT_FOUND
  SPACE_OWNER_NOT_FOUND
  SPACE_SHOULD_HAVE_ONLY_ONE_OWNER
  SSRF_BLOCKED_ERROR
  STORAGE_QUOTA_EXCEEDED
  SUBSCRIPTION_ALREADY_EXISTS
  SUBSCRIPTION_EXPIRED
  SUBSCRIPTION_HAS_BEEN_CANCELED
  SUBSCRIPTION_HAS_NOT_BEEN_CANCELED
  SUBSCRIPTION_NOT_EXISTS
  SUBSCRIPTION_PLAN_NOT_FOUND
  TOO_MANY_REQUEST
  UNKNOWN_OAUTH_PROVIDER
  UNSPLASH_IS_NOT_CONFIGURED
  UNSUPPORTED_CLIENT_VERSION
  UNSUPPORTED_SUBSCRIPTION_PLAN
  USER_AVATAR_NOT_FOUND
  USER_NOT_FOUND
  VALIDATION_ERROR
  VERSION_REJECTED
  WORKSPACE_ID_REQUIRED_FOR_TEAM_SUBSCRIPTION
  WORKSPACE_ID_REQUIRED_TO_UPDATE_TEAM_SUBSCRIPTION
  WORKSPACE_LICENSE_ALREADY_EXISTS
  WORKSPACE_PERMISSION_NOT_FOUND
  WRONG_SIGN_IN_CREDENTIALS
  WRONG_SIGN_IN_METHOD
}

type ExpectToGrantDocUserRolesDataType {
  docId: String!
  spaceId: String!
}

type ExpectToRevokeDocUserRolesDataType {
  docId: String!
  spaceId: String!
}

type ExpectToUpdateDocUserRoleDataType {
  docId: String!
  spaceId: String!
}

enum FeatureType {
  AIEarlyAccess
  Admin
  EarlyAccess
  FreePlan
  LifetimeProPlan
  ProPlan
  TeamPlan
  UnlimitedCopilot
  UnlimitedWorkspace
}

input ForkChatSessionInput {
  docId: String!

  """
  Identify a message in the array and keep it with all previous messages into a forked session.
  """
  latestMessageId: String
  sessionId: String!
  workspaceId: String!
}

input GenerateAccessTokenInput {
  expiresAt: DateTime
  name: String!
}

input GrantDocUserRolesInput {
  docId: String!
  role: DocRole!
  userIds: [String!]!
  workspaceId: String!
}

type GrantedDocUserType {
  role: DocRole!
  user: WorkspaceUserType!
}

type GrantedDocUserTypeEdge {
  cursor: String!
  node: GrantedDocUserType!
}

type GraphqlBadRequestDataType {
  code: String!
  message: String!
}

type HttpRequestErrorDataType {
  message: String!
}

input ImportUsersInput {
  users: [CreateUserInput!]!
}

type InvalidAppConfigDataType {
  hint: String!
  key: String!
  module: String!
}

type InvalidAppConfigInputDataType {
  message: String!
}

type InvalidEmailDataType {
  email: String!
}

type InvalidHistoryTimestampDataType {
  timestamp: String!
}

type InvalidIndexerInputDataType {
  reason: String!
}

type InvalidLicenseToActivateDataType {
  reason: String!
}

type InvalidLicenseUpdateParamsDataType {
  reason: String!
}

type InvalidOauthCallbackCodeDataType {
  body: String!
  status: Int!
}

type InvalidOauthResponseDataType {
  reason: String!
}

type InvalidPasswordLengthDataType {
  max: Int!
  min: Int!
}

type InvalidRuntimeConfigTypeDataType {
  get: String!
  key: String!
  want: String!
}

type InvalidSearchProviderRequestDataType {
  reason: String!
  type: String!
}

type InvitationAcceptedNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  inviteId: ID!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationBlockedNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  inviteId: ID!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  inviteId: ID!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationReviewApprovedNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  inviteId: ID!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationReviewDeclinedNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationReviewRequestNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  inviteId: ID!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type InvitationType {
  """Invitee information"""
  invitee: WorkspaceUserType!

  """Invitation status in workspace"""
  status: WorkspaceMemberStatus

  """User information"""
  user: WorkspaceUserType!

  """Workspace information"""
  workspace: InvitationWorkspaceType!
}

type InvitationWorkspaceType {
  """Base64 encoded avatar"""
  avatar: String!
  id: ID!

  """Workspace name"""
  name: String!
}

type InviteLink {
  """Invite link expire time"""
  expireTime: DateTime!

  """Invite link"""
  link: String!
}

input InviteOrgMemberInput {
  """Email of the user to invite"""
  email: String!

  """Organization ID"""
  organizationId: String!

  """Role to assign"""
  role: OrgRole! = Member
}

type InviteResult {
  email: String!

  """Invite error"""
  error: JSONObject

  """Invite id, null if invite record create failed"""
  inviteId: String

  """Invite email sent success"""
  sentSuccess: Boolean! @deprecated(reason: "Notification will be sent asynchronously")
}

type InviteUserType {
  """User avatar url"""
  avatarUrl: String

  """User email verified"""
  createdAt: DateTime @deprecated(reason: "useless")

  """User is disabled"""
  disabled: Boolean

  """User email"""
  email: String

  """User email verified"""
  emailVerified: Boolean

  """User password has been set"""
  hasPassword: Boolean
  id: ID!

  """Invite id"""
  inviteId: String!

  """User name"""
  name: String

  """User permission in workspace"""
  permission: Permission! @deprecated(reason: "Use role instead")

  """User role in workspace"""
  role: Permission!

  """Member invite status in workspace"""
  status: WorkspaceMemberStatus!
}

enum InvoiceStatus {
  Draft
  Open
  Paid
  Uncollectible
  Void
}

type InvoiceType {
  amount: Int!
  createdAt: DateTime!
  currency: String!
  id: String @deprecated(reason: "removed")
  lastPaymentError: String
  link: String
  plan: SubscriptionPlan @deprecated(reason: "removed")
  reason: String!
  recurring: SubscriptionRecurring @deprecated(reason: "removed")
  status: InvoiceStatus!
  updatedAt: DateTime!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type License {
  expiredAt: DateTime
  installedAt: DateTime!
  quantity: Int!
  recurring: SubscriptionRecurring!
  validatedAt: DateTime!
  variant: SubscriptionVariant
}

type LimitedUserType {
  """User email"""
  email: String!

  """User password has been set"""
  hasPassword: Boolean
}

input LinkCalDAVAccountInput {
  displayName: String
  password: String!
  providerPresetId: String!
  username: String!
}

input LinkCalendarAccountInput {
  provider: CalendarProviderType!
  redirectUri: String
}

input ListUserInput {
  features: [FeatureType!]
  first: Int = 20
  keyword: String
  skip: Int = 0
}

input ListWorkspaceInput {
  enableAi: Boolean
  enableDocEmbedding: Boolean
  enableSharing: Boolean
  enableUrlPreview: Boolean
  features: [FeatureType!]
  first: Int! = 20
  keyword: String
  orderBy: AdminWorkspaceSort
  public: Boolean
  skip: Int! = 0
}

type ListedBlob {
  createdAt: String!
  key: String!
  mime: String!
  size: Int!
}

input ManageUserInput {
  """User email"""
  email: String

  """User name"""
  name: String
}

type MemberNotFoundInSpaceDataType {
  spaceId: String!
}

input MentionDocInput {
  """The block id in the doc"""
  blockId: String

  """The element id in the doc"""
  elementId: String
  id: String!
  mode: DocMode!
  title: String!
}

type MentionDocType {
  blockId: String
  elementId: String
  id: String!
  mode: DocMode!
  title: String!
}

input MentionInput {
  doc: MentionDocInput!
  userId: String!
  workspaceId: String!
}

type MentionNotificationBodyType {
  """
  The user who created the notification, maybe null when user is deleted or sent by system
  """
  createdByUser: PublicUserType
  doc: MentionDocType!

  """The type of the notification"""
  type: NotificationType!
  workspace: NotificationWorkspaceType
}

type MentionUserDocAccessDeniedDataType {
  docId: String!
}

type MissingOauthQueryParameterDataType {
  name: String!
}

type Mutation {
  abortBlobUpload(key: String!, uploadId: String!, workspaceId: String!): Boolean!
  acceptInviteById(inviteId: String!, sendAcceptMail: Boolean @deprecated(reason: "never used"), workspaceId: String @deprecated(reason: "never used")): Boolean!

  """Accept an organization invitation"""
  acceptOrgInvitation(organizationId: String!): Boolean!
  activateLicense(license: String!, workspaceId: String!): License!

  """add a blob to context"""
  addContextBlob(options: AddContextBlobInput!): CopilotContextBlob!

  """add a category to context"""
  addContextCategory(options: AddContextCategoryInput!): CopilotContextCategory!

  """add a doc to context"""
  addContextDoc(options: AddContextDocInput!): CopilotContextDoc!

  """add a file to context"""
  addContextFile(content: Upload!, options: AddContextFileInput!): CopilotContextFile!

  """Update workspace embedding files"""
  addWorkspaceEmbeddingFiles(blob: Upload!, workspaceId: String!): CopilotWorkspaceFile!
  addWorkspaceFeature(feature: FeatureType!, workspaceId: String!): Boolean!
  adminMarkAffiliatePayoutFailed(input: AdminPayoutActionInput!): AffiliatePayoutType!
  adminMarkAffiliatePayoutPaid(input: AdminPayoutActionInput!): AffiliatePayoutType!
  adminUpdateAffiliate(input: AdminUpdateAffiliateInput!): AffiliateProfileType!

  """Update workspace flags and features for admin"""
  adminUpdateWorkspace(input: AdminUpdateWorkspaceInput!): AdminWorkspace

  """Apply updates to a doc using LLM and return the merged markdown."""
  applyDocUpdates(docId: String!, op: String!, updates: String!, workspaceId: String!): String!
  approveMember(userId: String!, workspaceId: String!): Boolean!

  """Assign a workspace to an organization"""
  assignWorkspaceToOrg(organizationId: String!, workspaceId: String!): Boolean!

  """Ban an user"""
  banUser(id: String!): UserType!
  cancelSubscription(idempotencyKey: String @deprecated(reason: "use header `Idempotency-Key`"), plan: SubscriptionPlan = Pro, workspaceId: String): SubscriptionType!
  captureAffiliateReferral(campaign: String, code: String!, source: String): Boolean!
  changeEmail(email: String!, token: String!): UserType!

  """Change the role of a member in an organization"""
  changeOrgMemberRole(organizationId: String!, role: OrgRole!, userId: String!): Boolean!
  changePassword(newPassword: String!, token: String!, userId: String): Boolean!
  claimAudioTranscription(jobId: String!): TranscriptionResultType

  """Cleanup sessions"""
  cleanupCopilotSession(options: DeleteSessionInput!): [String!]!
  completeBlobUpload(key: String!, parts: [BlobUploadPartInput!], uploadId: String, workspaceId: String!): String!
  createBlobUpload(key: String!, mime: String!, size: Int!, workspaceId: String!): BlobUploadInit!

  """Create change password url"""
  createChangePasswordUrl(callbackUrl: String!, userId: String!): String!

  """Create a subscription checkout link of stripe"""
  createCheckoutSession(input: CreateCheckoutSessionInput!): String!
  createComment(input: CommentCreateInput!): CommentObjectType!

  """Create a context session"""
  createCopilotContext(sessionId: String!, workspaceId: String!): String!

  """Create a chat message"""
  createCopilotMessage(options: CreateChatMessageInput!): String!

  """Create a copilot prompt"""
  createCopilotPrompt(input: CreateCopilotPromptInput!): CopilotPromptType!

  """Create a chat session"""
  createCopilotSession(options: CreateChatSessionInput!): String!

  """Create a stripe customer portal to manage payment methods"""
  createCustomerPortal: String!
  createInviteLink(expireTime: WorkspaceInviteLinkExpireTime!, workspaceId: String!): InviteLink!

  """Create a new organization"""
  createOrganization(input: CreateOrganizationInput!): OrganizationType!
  createReply(input: ReplyCreateInput!): ReplyObjectType!
  createSelfhostWorkspaceCustomerPortal(workspaceId: String!): String!

  """Create a new user"""
  createUser(input: CreateUserInput!): UserType!

  """Create a new workspace"""
  createWorkspace(init: Upload): WorkspaceType!
  deactivateLicense(workspaceId: String!): Boolean!
  deleteAccount: DeleteAccount!
  deleteBlob(hash: String @deprecated(reason: "use parameter [key]"), key: String, permanently: Boolean! = false, workspaceId: String!): Boolean!

  """Delete a comment"""
  deleteComment(id: String!): Boolean!

  """Delete an organization"""
  deleteOrganization(id: String!): Boolean!

  """Delete a reply"""
  deleteReply(id: String!): Boolean!

  """Delete a user account"""
  deleteUser(id: String!): DeleteAccount!
  deleteWorkspace(id: String!): Boolean!

  """Reenable an banned user"""
  enableUser(id: String!): UserType!

  """Create a chat session"""
  forkCopilotSession(options: ForkChatSessionInput!): String!
  generateLicenseKey(sessionId: String!): String!
  generateUserAccessToken(input: GenerateAccessTokenInput!): RevealedAccessToken!
  grantDocUserRoles(input: GrantDocUserRolesInput!): Boolean!
  grantMember(permission: Permission!, userId: String!, workspaceId: String!): Boolean!

  """import users"""
  importUsers(input: ImportUsersInput!): [UserImportResultType!]!
  installLicense(license: Upload!, workspaceId: String!): License!
  inviteMembers(emails: [String!]!, workspaceId: String!): [InviteResult!]!

  """Invite a user to an organization"""
  inviteOrgMember(input: InviteOrgMemberInput!): Boolean!
  leaveWorkspace(sendLeaveMail: Boolean @deprecated(reason: "no used anymore"), workspaceId: String!, workspaceName: String @deprecated(reason: "no longer used")): Boolean!
  linkCalDAVAccount(input: LinkCalDAVAccountInput!): CalendarAccountObjectType!
  linkCalendarAccount(input: LinkCalendarAccountInput!): String!

  """mention user in a doc"""
  mentionUser(input: MentionInput!): ID!
  publishDoc(docId: String!, mode: PublicDocMode = Page, workspaceId: String!): DocType!

  """queue workspace doc embedding"""
  queueWorkspaceEmbedding(docId: [String!]!, workspaceId: String!): Boolean!

  """mark all notifications as read"""
  readAllNotifications: Boolean!

  """mark notification as read"""
  readNotification(id: String!): Boolean!
  recoverDoc(guid: String!, timestamp: DateTime!, workspaceId: String!): DateTime!

  """Refresh current user subscriptions and return latest."""
  refreshUserSubscriptions: [SubscriptionType!]!
  releaseDeletedBlobs(workspaceId: String!): Boolean!

  """Remove user avatar"""
  removeAvatar: RemoveAvatar!

  """remove a blob from context"""
  removeContextBlob(options: RemoveContextBlobInput!): Boolean!

  """remove a category from context"""
  removeContextCategory(options: RemoveContextCategoryInput!): Boolean!

  """remove a doc from context"""
  removeContextDoc(options: RemoveContextDocInput!): Boolean!

  """remove a file from context"""
  removeContextFile(options: RemoveContextFileInput!): Boolean!

  """Remove a member from an organization"""
  removeOrgMember(organizationId: String!, userId: String!): Boolean!

  """Remove workspace embedding files"""
  removeWorkspaceEmbeddingFiles(fileId: String!, workspaceId: String!): Boolean!
  removeWorkspaceFeature(feature: FeatureType!, workspaceId: String!): Boolean!

  """Request to apply the subscription in advance"""
  requestApplySubscription(transactionId: String!): [SubscriptionType!]!

  """Resolve a comment or not"""
  resolveComment(input: CommentResolveInput!): Boolean!
  resumeSubscription(idempotencyKey: String @deprecated(reason: "use header `Idempotency-Key`"), plan: SubscriptionPlan = Pro, workspaceId: String): SubscriptionType!
  retryAudioTranscription(jobId: String!, workspaceId: String!): TranscriptionResultType
  revokeDocUserRoles(input: RevokeDocUserRoleInput!): Boolean!
  revokeInviteLink(workspaceId: String!): Boolean!
  revokeMember(userId: String!, workspaceId: String!): Boolean!
  revokePublicDoc(docId: String!, workspaceId: String!): DocType!
  revokeUserAccessToken(id: String!): Boolean!
  runAffiliatePayouts: Int!
  sendChangeEmail(callbackUrl: String!, email: String): Boolean!
  sendChangePasswordEmail(callbackUrl: String!, email: String @deprecated(reason: "fetched from signed in user")): Boolean!
  sendSetPasswordEmail(callbackUrl: String!, email: String @deprecated(reason: "fetched from signed in user")): Boolean!
  sendTestEmail(config: JSONObject!): Boolean!
  sendVerifyChangeEmail(callbackUrl: String!, email: String!, token: String!): Boolean!
  sendVerifyEmail(callbackUrl: String!): Boolean!
  setBlob(blob: Upload!, workspaceId: String!): String!
  setupAffiliateStripeConnect(input: SetupStripeConnectInput!): StripeConnectLinkType!
  submitAudioTranscription(blob: Upload, blobId: String!, blobs: [Upload!], workspaceId: String!): TranscriptionResultType

  """Trigger cleanup of trashed doc embeddings"""
  triggerCleanupTrashedDocEmbeddings: Boolean!

  """Trigger generate missing titles cron job"""
  triggerGenerateTitleCron: Boolean!

  """Unassign a workspace from an organization"""
  unassignWorkspaceFromOrg(organizationId: String!, workspaceId: String!): Boolean!
  unlinkCalendarAccount(accountId: String!): Boolean!

  """update app configuration"""
  updateAppConfig(updates: [UpdateAppConfigInput!]!): JSONObject!
  updateCalendarAccount(accountId: String!, refreshIntervalMinutes: Int!): CalendarAccountObjectType

  """Update a comment content"""
  updateComment(input: CommentUpdateInput!): Boolean!

  """Update a copilot prompt"""
  updateCopilotPrompt(messages: [CopilotPromptMessageInput!]!, name: String!): CopilotPromptType!

  """Update a chat session"""
  updateCopilotSession(options: UpdateChatSessionInput!): String!
  updateDocDefaultRole(input: UpdateDocDefaultRoleInput!): Boolean!
  updateDocUserRole(input: UpdateDocUserRoleInput!): Boolean!

  """Update an organization"""
  updateOrganization(input: UpdateOrganizationInput!): OrganizationType!
  updateProfile(input: UpdateUserInput!): UserType!

  """Update a reply content"""
  updateReply(input: ReplyUpdateInput!): Boolean!

  """Update user settings"""
  updateSettings(input: UpdateUserSettingsInput!): Boolean!
  updateSubscriptionRecurring(idempotencyKey: String @deprecated(reason: "use header `Idempotency-Key`"), plan: SubscriptionPlan = Pro, recurring: SubscriptionRecurring!, workspaceId: String): SubscriptionType!

  """Update an user"""
  updateUser(id: String!, input: ManageUserInput!): UserType!

  """update user enabled feature"""
  updateUserFeatures(features: [FeatureType!]!, id: String!): [FeatureType!]!

  """Update workspace"""
  updateWorkspace(input: UpdateWorkspaceInput!): WorkspaceType!
  updateWorkspaceCalendars(input: UpdateWorkspaceCalendarsInput!): WorkspaceCalendarObjectType!

  """Update ignored docs"""
  updateWorkspaceEmbeddingIgnoredDocs(add: [String!], remove: [String!], workspaceId: String!): Int!

  """Upload user avatar"""
  uploadAvatar(avatar: Upload!): UserType!

  """Upload a comment attachment and return the access url"""
  uploadCommentAttachment(attachment: Upload!, docId: String!, workspaceId: String!): String!
  upsertAffiliateProfile(input: UpsertAffiliateProfileInput!): AffiliateProfileType!
  verifyEmail(token: String!): Boolean!
}

type NoCopilotProviderAvailableDataType {
  modelId: String!
}

type NoMoreSeatDataType {
  spaceId: String!
}

type NotInSpaceDataType {
  spaceId: String!
}

"""Notification level"""
enum NotificationLevel {
  Default
  High
  Low
  Min
  None
}

type NotificationObjectType {
  """Just a placeholder to export UnionNotificationBodyType, don't use it"""
  _placeholderForUnionNotificationBodyType: UnionNotificationBodyType!

  """
  The body of the notification, different types have different fields, see UnionNotificationBodyType
  """
  body: JSONObject!

  """The created at time of the notification"""
  createdAt: DateTime!
  id: ID!

  """The level of the notification"""
  level: NotificationLevel!

  """Whether the notification has been read"""
  read: Boolean!

  """The type of the notification"""
  type: NotificationType!

  """The updated at time of the notification"""
  updatedAt: DateTime!
}

type NotificationObjectTypeEdge {
  cursor: String!
  node: NotificationObjectType!
}

"""Notification type"""
enum NotificationType {
  Comment
  CommentMention
  Invitation
  InvitationAccepted
  InvitationBlocked
  InvitationRejected
  InvitationReviewApproved
  InvitationReviewDeclined
  InvitationReviewRequest
  Mention
}

type NotificationWorkspaceType {
  """Workspace avatar url"""
  avatarUrl: String
  id: ID!

  """Workspace name"""
  name: String!
}

enum OAuthProviderType {
  Apple
  GitHub
  Google
  OIDC
}

type OrgMemberType {
  """Member joined date"""
  createdAt: DateTime!
  id: ID!

  """User role in organization"""
  role: OrgRole!

  """Member status in organization"""
  status: OrganizationMemberStatus!

  """Member user info"""
  user: WorkspaceUserType!
}

"""User role in organization"""
enum OrgRole {
  Admin
  Member
  Owner
}

type OrgWorkspaceType {
  """Workspace created date"""
  createdAt: DateTime!
  id: ID!

  """Workspace name"""
  name: String
}

"""Member status in organization"""
enum OrganizationMemberStatus {
  Accepted
  Pending
}

type OrganizationType {
  """Avatar key"""
  avatarKey: String

  """Organization created date"""
  createdAt: DateTime!
  id: ID!

  """Number of members in the organization"""
  memberCount: Int!

  """Members of organization"""
  members(skip: Int, take: Int): [OrgMemberType!]!

  """Organization name"""
  name: String!

  """Organization slug (URL-friendly identifier)"""
  slug: String!

  """Workspaces belonging to the organization"""
  workspaces: [OrgWorkspaceType!]!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type PaginatedAdminAllSharedLink {
  analyticsWindow: TimeWindow!
  edges: [AdminAllSharedLinkEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type PaginatedCommentChangeObjectType {
  edges: [CommentChangeObjectTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedCommentObjectType {
  edges: [CommentObjectTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedCopilotHistoriesType {
  edges: [CopilotHistoriesTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedCopilotWorkspaceFileType {
  edges: [CopilotWorkspaceFileTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedDocMemberLastAccess {
  edges: [DocMemberLastAccessEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type PaginatedDocType {
  edges: [DocTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedGrantedDocUserType {
  edges: [GrantedDocUserTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedIgnoredDocsType {
  edges: [CopilotWorkspaceIgnoredDocTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type PaginatedNotificationObjectType {
  edges: [NotificationObjectTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input PaginationInput {
  """returns the elements in the list that come after the specified cursor."""
  after: String

  """returns the first n elements from the list."""
  first: Int = 10

  """ignore the first n elements from the list."""
  offset: Int = 0
}

type PasswordLimitsType {
  maxLength: Int!
  minLength: Int!
}

"""User permission in workspace"""
enum Permission {
  Admin
  Collaborator
  External
  Owner
}

"""The mode which the public doc default in"""
enum PublicDocMode {
  Edgeless
  Page
}

type PublicUserType {
  avatarUrl: String
  id: String!
  name: String!
}

type Query {
  adminAffiliateOverview(periodDays: Int = 30): AffiliateAdminOverviewType!
  adminAffiliatePayoutDetail(payoutId: String!): AffiliateAdminPayoutDetailType!
  adminAffiliates(first: Int = 50, keyword: String, skip: Int = 0): [AffiliateAdminListItemType!]!

  """List all shared links across workspaces for admin panel"""
  adminAllSharedLinks(filter: AdminAllSharedLinksFilterInput, pagination: PaginationInput!): PaginatedAdminAllSharedLink!

  """Get aggregated dashboard metrics for admin panel"""
  adminDashboard(input: AdminDashboardInput): AdminDashboard!
  adminRecentAffiliatePayouts(limit: Int = 50): [AffiliatePayoutType!]!

  """Get workspace detail for admin"""
  adminWorkspace(id: String!): AdminWorkspace

  """List workspaces for admin"""
  adminWorkspaces(filter: ListWorkspaceInput!): [AdminWorkspace!]!

  """Workspaces count for admin"""
  adminWorkspacesCount(filter: ListWorkspaceInput!): Int!

  """get the whole app configuration"""
  appConfig: JSONObject!

  """Apply updates to a doc using LLM and return the merged markdown."""
  applyDocUpdates(docId: String!, op: String!, updates: String!, workspaceId: String!): String! @deprecated(reason: "use Mutation.applyDocUpdates")

  """Get current user"""
  currentUser: UserType
  error(name: ErrorNames!): ErrorDataUnion!

  """get workspace invitation info"""
  getInviteInfo(inviteId: String!): InvitationType!

  """List all copilot prompts"""
  listCopilotPrompts: [CopilotPromptType!]!
  myAffiliateDashboard: AffiliateDashboardType!
  myAffiliateProfile: AffiliateProfileType!

  """Get organization by id"""
  organization(id: String!): OrganizationType!

  """Get all organizations for the current user"""
  organizations: [OrganizationType!]!
  prices: [SubscriptionPrice!]!

  """Get public user by id"""
  publicUserById(id: String!): PublicUserType

  """query workspace embedding status"""
  queryWorkspaceEmbeddingStatus(workspaceId: String!): ContextWorkspaceEmbeddingStatus!
  revealedAccessTokens: [RevealedAccessToken!]! @deprecated(reason: "use currentUser.revealedAccessTokens")

  """server config"""
  serverConfig: ServerConfigType!

  """Get user by email"""
  user(email: String!): UserOrLimitedUser

  """Get user by email for admin"""
  userByEmail(email: String!): UserType

  """Get user by id"""
  userById(id: String!): UserType!

  """List registered users"""
  users(filter: ListUserInput!): [UserType!]!

  """Get users count"""
  usersCount(filter: ListUserInput): Int!

  """validate app configuration"""
  validateAppConfig(updates: [UpdateAppConfigInput!]!): [AppConfigValidateResult!]!

  """Get workspace by id"""
  workspace(id: String!): WorkspaceType!

  """Get workspace role permissions"""
  workspaceRolePermissions(id: String!): WorkspaceRolePermissions! @deprecated(reason: "use WorkspaceType[permissions] instead")

  """Get all accessible workspaces for current user"""
  workspaces: [WorkspaceType!]!
}

input QueryChatHistoriesInput {
  action: Boolean
  fork: Boolean
  limit: Int
  messageOrder: ChatHistoryOrder
  pinned: Boolean
  sessionId: String
  sessionOrder: ChatHistoryOrder
  skip: Int
  withMessages: Boolean
  withPrompt: Boolean
}

input QueryChatSessionsInput {
  action: Boolean
  fork: Boolean
  limit: Int
  pinned: Boolean
  skip: Int
}

type QueryTooLongDataType {
  max: Int!
}

type ReleaseVersionType {
  changelog: String!
  publishedAt: DateTime!
  url: String!
  version: String!
}

type RemoveAvatar {
  success: Boolean!
}

input RemoveContextBlobInput {
  blobId: String!
  contextId: String!
}

input RemoveContextCategoryInput {
  categoryId: String!
  contextId: String!
  type: ContextCategories!
}

input RemoveContextDocInput {
  contextId: String!
  docId: String!
}

input RemoveContextFileInput {
  contextId: String!
  fileId: String!
}

input ReplyCreateInput {
  commentId: ID!
  content: JSONObject!
  docMode: DocMode!
  docTitle: String!

  """
  The mention user ids, if not provided, the comment reply will not be mentioned
  """
  mentions: [String!]
}

type ReplyObjectType {
  commentId: ID!

  """The content of the reply"""
  content: JSONObject!

  """The created at time of the reply"""
  createdAt: DateTime!
  id: ID!

  """The updated at time of the reply"""
  updatedAt: DateTime!

  """The user who created the reply"""
  user: PublicUserType!
}

input ReplyUpdateInput {
  content: JSONObject!
  id: ID!
}

type ResponseTooLargeErrorDataType {
  limitBytes: Int!
  receivedBytes: Int!
}

type RevealedAccessToken {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  name: String!
  token: String!
}

input RevokeDocUserRoleInput {
  docId: String!
  userId: String!
  workspaceId: String!
}

type RuntimeConfigNotFoundDataType {
  key: String!
}

"""
The `SafeInt` scalar type represents non-fractional signed whole numeric values that are considered safe as defined by the ECMAScript specification.
"""
scalar SafeInt @specifiedBy(url: "https://www.ecma-international.org/ecma-262/#sec-number.issafeinteger")

type SameSubscriptionRecurringDataType {
  recurring: String!
}

type SearchDocObjectType {
  blockId: String!
  createdAt: DateTime!
  createdByUser: PublicUserType
  docId: String!
  highlight: String!
  title: String!
  updatedAt: DateTime!
  updatedByUser: PublicUserType
}

input SearchDocsInput {
  keyword: String!

  """Limit the number of docs to return, default is 20"""
  limit: Int
}

input SearchHighlight {
  before: String!
  end: String!
  field: String!
}

input SearchInput {
  options: SearchOptions!
  query: SearchQuery!
  table: SearchTable!
}

type SearchNodeObjectType {
  """The search result fields, see UnionSearchItemObjectType"""
  fields: JSONObject!

  """The search result fields, see UnionSearchItemObjectType"""
  highlights: JSONObject
}

input SearchOptions {
  fields: [String!]!
  highlights: [SearchHighlight!]
  pagination: SearchPagination
}

input SearchPagination {
  cursor: String
  limit: Int
  skip: Int
}

input SearchQuery {
  boost: Float
  field: String
  match: String
  occur: SearchQueryOccur
  queries: [SearchQuery!]
  query: SearchQuery
  type: SearchQueryType!
}

"""Search query occur"""
enum SearchQueryOccur {
  must
  must_not
  should
}

"""Search query type"""
enum SearchQueryType {
  all
  boolean
  boost
  exists
  match
}

type SearchResultObjectType {
  nodes: [SearchNodeObjectType!]!
  pagination: SearchResultPagination!
}

type SearchResultPagination {
  count: Int!
  hasMore: Boolean!
  nextCursor: String
}

"""Search table"""
enum SearchTable {
  block
  doc
}

type ServerConfigType {
  """fetch latest available upgradable release of server"""
  availableUpgrade: ReleaseVersionType

  """Features for user that can be configured"""
  availableUserFeatures: [FeatureType!]!

  """Workspace features available for admin configuration"""
  availableWorkspaceFeatures: [FeatureType!]!

  """server base url"""
  baseUrl: String!
  calendarCalDAVProviders: [CalendarCalDAVProviderPresetObjectType!]!
  calendarProviders: [CalendarProviderType!]!

  """credentials requirement"""
  credentialsRequirement: CredentialsRequirementType!

  """enabled server features"""
  features: [ServerFeature!]!

  """whether server has been initialized"""
  initialized: Boolean!

  """server identical name could be shown as badge on user interface"""
  name: String!
  oauthProviders: [OAuthProviderType!]!

  """server type"""
  type: ServerDeploymentType!

  """server version"""
  version: String!
}

enum ServerDeploymentType {
  Subsumio
  Selfhosted
}

enum ServerFeature {
  Captcha
  Comment
  Copilot
  CopilotEmbedding
  Indexer
  LocalWorkspace
  OAuth
  Payment
}

input SetupStripeConnectInput {
  country: String!
  email: String
}

type SpaceAccessDeniedDataType {
  spaceId: String!
}

type SpaceNotFoundDataType {
  spaceId: String!
}

type SpaceOwnerNotFoundDataType {
  spaceId: String!
}

type SpaceShouldHaveOnlyOneOwnerDataType {
  spaceId: String!
}

type SsrfBlockedErrorDataType {
  reason: String!
}

type StreamObject {
  args: JSON
  result: JSON
  textDelta: String
  toolCallId: String
  toolName: String
  type: String!
}

type StripeConnectLinkType {
  url: String!
}

type SubscriptionAlreadyExistsDataType {
  plan: String!
}

type SubscriptionNotExistsDataType {
  plan: String!
}

enum SubscriptionPlan {
  AI
  Enterprise
  Free
  Pro
  SelfHosted
  SelfHostedTeam
  Team
}

type SubscriptionPlanNotFoundDataType {
  plan: String!
  recurring: String!
}

type SubscriptionPrice {
  amount: Int
  currency: String!
  lifetimeAmount: Int
  plan: SubscriptionPlan!
  type: String!
  yearlyAmount: Int
}

enum SubscriptionRecurring {
  Lifetime
  Monthly
  Yearly
}

enum SubscriptionStatus {
  Active
  Canceled
  Incomplete
  IncompleteExpired
  PastDue
  Paused
  Trialing
  Unpaid
}

type SubscriptionType {
  canceledAt: DateTime
  createdAt: DateTime!
  end: DateTime

  """
  If provider is revenuecat, indicates underlying store. Read-only. One of: app_store | play_store
  """
  iapStore: String
  id: String @deprecated(reason: "removed")
  nextBillAt: DateTime

  """
  The 'Free' plan just exists to be a placeholder and for the type convenience of frontend.
  There won't actually be a subscription with plan 'Free'
  """
  plan: SubscriptionPlan!

  """
  Payment provider of this subscription. Read-only. One of: stripe | revenuecat
  """
  provider: String
  recurring: SubscriptionRecurring!
  start: DateTime!
  status: SubscriptionStatus!
  trialEnd: DateTime
  trialStart: DateTime
  updatedAt: DateTime!
  variant: SubscriptionVariant
}

enum SubscriptionVariant {
  EA
  Onetime
}

enum TimeBucket {
  Day
  Minute
}

type TimeWindow {
  bucket: TimeBucket!
  effectiveSize: Int!
  from: DateTime!
  requestedSize: Int!
  timezone: String!
  to: DateTime!
}

type TranscriptionItemType {
  end: String!
  speaker: String!
  start: String!
  transcription: String!
}

type TranscriptionResultType {
  actions: String
  id: ID!
  status: AiJobStatus!
  summary: String
  title: String
  transcription: [TranscriptionItemType!]
}

union UnionNotificationBodyType = InvitationAcceptedNotificationBodyType | InvitationBlockedNotificationBodyType | InvitationNotificationBodyType | InvitationReviewApprovedNotificationBodyType | InvitationReviewDeclinedNotificationBodyType | InvitationReviewRequestNotificationBodyType | MentionNotificationBodyType

type UnknownOauthProviderDataType {
  name: String!
}

type UnsupportedClientVersionDataType {
  clientVersion: String!
  requiredVersion: String!
}

type UnsupportedSubscriptionPlanDataType {
  plan: String!
}

input UpdateAppConfigInput {
  key: String!
  module: String!
  value: JSON!
}

input UpdateChatSessionInput {
  """The workspace id of the session"""
  docId: String

  """Whether to pin the session"""
  pinned: Boolean

  """The prompt name to use for the session"""
  promptName: String
  sessionId: String!
}

input UpdateDocDefaultRoleInput {
  docId: String!
  role: DocRole!
  workspaceId: String!
}

input UpdateDocUserRoleInput {
  docId: String!
  role: DocRole!
  userId: String!
  workspaceId: String!
}

input UpdateOrganizationInput {
  id: ID!

  """Organization name"""
  name: String

  """Organization slug"""
  slug: String
}

input UpdateUserInput {
  """User name"""
  name: String
}

input UpdateUserSettingsInput {
  """Receive comment email"""
  receiveCommentEmail: Boolean

  """Receive invitation email"""
  receiveInvitationEmail: Boolean

  """Receive mention email"""
  receiveMentionEmail: Boolean
}

input UpdateWorkspaceCalendarsInput {
  items: [WorkspaceCalendarItemInput!]!
  workspaceId: String!
}

input UpdateWorkspaceInput {
  """Enable AI"""
  enableAi: Boolean

  """Enable doc embedding"""
  enableDocEmbedding: Boolean

  """Enable workspace sharing"""
  enableSharing: Boolean

  """Enable url previous when sharing"""
  enableUrlPreview: Boolean
  id: ID!

  """is Public workspace"""
  public: Boolean
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

input UpsertAffiliateProfileInput {
  acceptTerms: Boolean
  legalName: String
  levelOneRateBps: Int
  levelTwoRateBps: Int
  parentReferralCode: String
  payoutEmail: String
  taxCountry: String
  taxId: String
}

type UserImportFailedType {
  email: String!
  error: String!
}

union UserImportResultType = UserImportFailedType | UserType

union UserOrLimitedUser = LimitedUserType | UserType

type UserQuotaHumanReadableType {
  blobLimit: String!
  copilotActionLimit: String!
  historyPeriod: String!
  memberLimit: String!
  name: String!
  storageQuota: String!
  usedStorageQuota: String!
}

type UserQuotaType {
  blobLimit: SafeInt!
  copilotActionLimit: Int
  historyPeriod: SafeInt!
  humanReadable: UserQuotaHumanReadableType!
  memberLimit: Int!
  name: String!
  storageQuota: SafeInt!
  usedStorageQuota: SafeInt!
}

type UserQuotaUsageType {
  storageQuota: SafeInt! @deprecated(reason: "use `UserQuotaType['usedStorageQuota']` instead")
}

type UserSettingsType {
  """Receive comment email"""
  receiveCommentEmail: Boolean!

  """Receive invitation email"""
  receiveInvitationEmail: Boolean!

  """Receive mention email"""
  receiveMentionEmail: Boolean!
}

type UserType {
  accessTokens: [AccessToken!]!

  """User avatar url"""
  avatarUrl: String
  calendarAccounts: [CalendarAccountObjectType!]!
  copilot(workspaceId: String): Copilot!

  """User email verified"""
  createdAt: DateTime @deprecated(reason: "useless")

  """User is disabled"""
  disabled: Boolean!

  """User email"""
  email: String!

  """User email verified"""
  emailVerified: Boolean!

  """Enabled features of a user"""
  features: [FeatureType!]!

  """User password has been set"""
  hasPassword: Boolean
  id: ID!

  """Get user invoice count"""
  invoiceCount: Int!
  invoices(skip: Int, take: Int = 8): [InvoiceType!]!

  """User name"""
  name: String!

  """Get user notification count"""
  notificationCount: Int!

  """Get current user notifications"""
  notifications(pagination: PaginationInput!): PaginatedNotificationObjectType!
  quota: UserQuotaType!
  quotaUsage: UserQuotaUsageType!
  revealedAccessTokens: [RevealedAccessToken!]!

  """Get user settings"""
  settings: UserSettingsType!
  subscriptions: [SubscriptionType!]!
  token: tokenType! @deprecated(reason: "use [/api/auth/sign-in?native=true] instead")
}

type ValidationErrorDataType {
  errors: String!
}

type VersionRejectedDataType {
  serverVersion: String!
  version: String!
}

input WorkspaceCalendarItemInput {
  colorOverride: String
  sortOrder: Int
  subscriptionId: String!
}

type WorkspaceCalendarItemObjectType {
  colorOverride: String
  enabled: Boolean!
  id: String!
  sortOrder: Int
  subscriptionId: String!
}

type WorkspaceCalendarObjectType {
  colorOverride: String
  createdByUserId: String!
  displayNameOverride: String
  enabled: Boolean!
  events(from: DateTime!, to: DateTime!): [CalendarEventObjectType!]!
  id: String!
  items: [WorkspaceCalendarItemObjectType!]!
  workspaceId: String!
}

type WorkspaceDocMeta {
  createdAt: DateTime!
  createdBy: EditorType
  updatedAt: DateTime!
  updatedBy: EditorType
}

"""Workspace invite link expire time"""
enum WorkspaceInviteLinkExpireTime {
  OneDay
  OneMonth
  OneWeek
  ThreeDays
}

"""Member invite status in workspace"""
enum WorkspaceMemberStatus {
  Accepted
  AllocatingSeat
  NeedMoreSeat
  NeedMoreSeatAndReview
  Pending
  UnderReview
}

type WorkspacePermissionNotFoundDataType {
  spaceId: String!
}

type WorkspacePermissions {
  Workspace_Administrators_Manage: Boolean!
  Workspace_Blobs_List: Boolean!
  Workspace_Blobs_Read: Boolean!
  Workspace_Blobs_Write: Boolean!
  Workspace_Copilot: Boolean!
  Workspace_CreateDoc: Boolean!
  Workspace_Delete: Boolean!
  Workspace_Organize_Read: Boolean!
  Workspace_Payment_Manage: Boolean!
  Workspace_Properties_Create: Boolean!
  Workspace_Properties_Delete: Boolean!
  Workspace_Properties_Read: Boolean!
  Workspace_Properties_Update: Boolean!
  Workspace_Read: Boolean!
  Workspace_Settings_Read: Boolean!
  Workspace_Settings_Update: Boolean!
  Workspace_Sync: Boolean!
  Workspace_TransferOwner: Boolean!
  Workspace_Users_Manage: Boolean!
  Workspace_Users_Read: Boolean!
}

type WorkspaceQuotaHumanReadableType {
  blobLimit: String!
  historyPeriod: String!
  memberCount: String!
  memberLimit: String!
  name: String!
  overcapacityMemberCount: String!
  storageQuota: String!
  storageQuotaUsed: String!
}

type WorkspaceQuotaType {
  blobLimit: SafeInt!
  historyPeriod: SafeInt!
  humanReadable: WorkspaceQuotaHumanReadableType!
  memberCount: Int!
  memberLimit: Int!
  name: String!
  overcapacityMemberCount: Int!
  storageQuota: SafeInt!
  usedSize: SafeInt! @deprecated(reason: "use `usedStorageQuota` instead")
  usedStorageQuota: SafeInt!
}

type WorkspaceRolePermissions {
  permissions: WorkspacePermissions!
  role: Permission!
}

type WorkspaceType {
  """Search a specific table with aggregate"""
  aggregate(input: AggregateInput!): AggregateResultObjectType!

  """Get blob upload part url"""
  blobUploadPartUrl(key: String!, partNumber: Int!, uploadId: String!): BlobUploadPart!

  """List blobs of workspace"""
  blobs: [ListedBlob!]!

  """Blobs size of workspace"""
  blobsSize: Int!
  calendars: [WorkspaceCalendarObjectType!]!

  """Get comment changes of a doc"""
  commentChanges(docId: String!, pagination: PaginationInput!): PaginatedCommentChangeObjectType!

  """Get comments of a doc"""
  comments(docId: String!, pagination: PaginationInput): PaginatedCommentObjectType!

  """Workspace created date"""
  createdAt: DateTime!

  """Get get with given id"""
  doc(docId: String!): DocType!
  docs(pagination: PaginationInput!): PaginatedDocType!
  embedding: CopilotWorkspaceConfig!

  """Enable AI"""
  enableAi: Boolean!

  """Enable doc embedding"""
  enableDocEmbedding: Boolean!

  """Enable workspace sharing"""
  enableSharing: Boolean!

  """Enable url previous when sharing"""
  enableUrlPreview: Boolean!
  histories(before: DateTime, guid: String!, take: Int): [DocHistoryType!]!
  id: ID!

  """is current workspace initialized"""
  initialized: Boolean!

  """invite link for workspace"""
  inviteLink: InviteLink

  """Get user invoice count"""
  invoiceCount: Int!
  invoices(skip: Int, take: Int = 8): [InvoiceType!]!

  """The selfhost license of the workspace"""
  license: License

  """member count of workspace"""
  memberCount: Int!

  """Members of workspace"""
  members(query: String, skip: Int, take: Int): [InviteUserType!]!

  """Owner of workspace"""
  owner: UserType!

  """Cloud page metadata of workspace"""
  pageMeta(pageId: String!): WorkspaceDocMeta! @deprecated(reason: "use [WorkspaceType.doc] instead")

  """map of action permissions"""
  permissions: WorkspacePermissions!

  """is Public workspace"""
  public: Boolean!

  """Get public docs of a workspace"""
  publicDocs: [DocType!]!

  """quota of workspace"""
  quota: WorkspaceQuotaType!

  """Get recently updated docs of a workspace"""
  recentlyUpdatedDocs(pagination: PaginationInput!): PaginatedDocType!

  """Role of current signed in user in workspace"""
  role: Permission!

  """Search a specific table"""
  search(input: SearchInput!): SearchResultObjectType!

  """Search docs by keyword"""
  searchDocs(input: SearchDocsInput!): [SearchDocObjectType!]!

  """The team subscription of the workspace, if exists."""
  subscription: SubscriptionType

  """if workspace is team workspace"""
  team: Boolean!
}

type WorkspaceUserType {
  avatarUrl: String
  email: String!
  id: String!
  name: String!
}

type WrongSignInCredentialsDataType {
  email: String!
}

type tokenType {
  refresh: String!
  sessionToken: String
  token: String!
}