import { isIP } from 'node:net';

import { Injectable } from '@nestjs/common';
import type { Response } from 'express';
import { ClsService } from 'nestjs-cls';

import { Config } from '../config';
import { ActionForbidden } from '../error';
import { OnEvent } from '../event';

const ALLOWED_REDIRECT_PROTOCOLS = new Set(['http:', 'https:']);
// Keep in sync with frontend /redirect-proxy allowlist.
const TRUSTED_REDIRECT_DOMAINS = [
  'google.com',
  'stripe.com',
  'github.com',
  'twitter.com',
  'discord.gg',
  'youtube.com',
  't.me',
  'reddit.com',
  'subsumio.com',
  'subsum.io',
].map(d => d.toLowerCase());

function normalizeHostname(hostname: string) {
  return hostname.toLowerCase().replace(/\.$/, '');
}

function hostnameMatchesDomain(hostname: string, domain: string) {
  return hostname === domain || hostname.endsWith(`.${domain}`);
}

function parseAllowedOrigins(input: string): string[] {
  const raw = input
    .split(',')
    .map(s => s.trim())
    .filter(Boolean);

  const origins: string[] = [];
  for (const item of raw) {
    try {
      const url = new URL(item);
      if (!['http:', 'https:'].includes(url.protocol)) {
        continue;
      }
      origins.push(url.origin);
    } catch {
      // ignore invalid
    }
  }
  return Array.from(new Set(origins));
}

@Injectable()
export class URLHelper {
  redirectAllowHosts!: string[];

  origin!: string;
  allowedOrigins!: string[];
  baseUrl!: string;

  constructor(
    private readonly config: Config,
    private readonly cls?: ClsService
  ) {
    this.init();
  }

  @OnEvent('config.changed')
  @OnEvent('config.init')
  init() {
    if (this.config.server.externalUrl) {
      if (!this.verify(this.config.server.externalUrl)) {
        throw new Error(
          'Invalid `server.externalUrl` configured. It must be a valid url.'
        );
      }

      const externalUrl = new URL(this.config.server.externalUrl);

      this.origin = externalUrl.origin;
      this.baseUrl =
        externalUrl.origin + externalUrl.pathname.replace(/\/$/, '');
    } else {
      this.origin = this.convertHostToOrigin(this.config.server.host);
      this.baseUrl = this.origin + this.config.server.path;
    }

    this.redirectAllowHosts = [this.baseUrl];

    const configuredAllowedOrigins = this.config.server.allowedOrigins
      ? parseAllowedOrigins(this.config.server.allowedOrigins)
      : [];

    if (configuredAllowedOrigins.length > 0) {
      this.allowedOrigins = configuredAllowedOrigins;
    } else {
      this.allowedOrigins = [this.origin];
      if (this.config.server.hosts.length > 0) {
        for (const host of this.config.server.hosts) {
          this.allowedOrigins.push(this.convertHostToOrigin(host));
        }
      }
    }
  }

  get requestOrigin() {
    if (this.config.server.hosts.length === 0) {
      return this.origin;
    }

    // support multiple hosts
    const requestHost = this.cls?.get<string | undefined>(CLS_REQUEST_HOST);
    if (!requestHost || !this.config.server.hosts.includes(requestHost)) {
      return this.origin;
    }

    return this.convertHostToOrigin(requestHost);
  }

  get requestBaseUrl() {
    if (this.config.server.hosts.length === 0) {
      return this.baseUrl;
    }

    return this.requestOrigin + this.config.server.path;
  }

  stringify(query: Record<string, any>) {
    return new URLSearchParams(query).toString();
  }

  addSimpleQuery(
    url: string,
    key: string,
    value: string | number | boolean,
    escape = true
  ) {
    const urlObj = new URL(url);
    if (escape) {
      urlObj.searchParams.set(key, String(value));
      return urlObj.toString();
    } else {
      const query =
        (urlObj.search ? urlObj.search + '&' : '?') + `${key}=${value}`;

      return urlObj.origin + urlObj.pathname + query;
    }
  }

  url(path: string, query: Record<string, any> = {}) {
    const url = new URL(path, this.requestOrigin);

    for (const key in query) {
      url.searchParams.set(key, query[key]);
    }

    return url;
  }

  link(path: string, query: Record<string, any> = {}) {
    return this.url(path, query).toString();
  }

  safeLink(path: string, query: Record<string, any> = {}) {
    if (!this.isAllowedCallbackUrl(path)) {
      throw new ActionForbidden();
    }
    return this.link(path, query);
  }

  safeRedirect(res: Response, to: string) {
    try {
      const finalTo = new URL(decodeURIComponent(to), this.requestBaseUrl);

      for (const host of this.redirectAllowHosts) {
        const hostURL = new URL(host);
        if (
          hostURL.origin === finalTo.origin &&
          finalTo.pathname.startsWith(hostURL.pathname)
        ) {
          return res.redirect(finalTo.toString().replace(/\/$/, ''));
        }
      }
    } catch {
      // just ignore invalid url
    }

    // redirect to home if the url is invalid
    return res.redirect(this.baseUrl);
  }

  isAllowedCallbackUrl(url: string): boolean {
    if (!url) {
      return false;
    }

    // Allow same-app relative paths (e.g. `/magic-link?...`).
    if (url.startsWith('/') && !url.startsWith('//')) {
      return true;
    }

    try {
      const u = new URL(url);
      if (!ALLOWED_REDIRECT_PROTOCOLS.has(u.protocol)) {
        return false;
      }
      if (u.username || u.password) {
        return false;
      }
      return this.allowedOrigins.includes(u.origin);
    } catch {
      return false;
    }
  }

  isAllowedRedirectUri(redirectUri: string): boolean {
    if (!redirectUri) {
      return false;
    }

    // Allow internal navigation (e.g. `/` or `/redirect-proxy?...`).
    if (redirectUri.startsWith('/') && !redirectUri.startsWith('//')) {
      return true;
    }

    try {
      const u = new URL(redirectUri);
      if (!ALLOWED_REDIRECT_PROTOCOLS.has(u.protocol)) {
        return false;
      }
      if (u.username || u.password) {
        return false;
      }

      const hostname = normalizeHostname(u.hostname);

      // Allow server known hosts.
      for (const origin of this.allowedOrigins) {
        const allowedHost = normalizeHostname(new URL(origin).hostname);
        if (hostname === allowedHost) {
          return true;
        }
      }

      // Allow known trusted domains (for redirect-proxy).
      return TRUSTED_REDIRECT_DOMAINS.some(domain =>
        hostnameMatchesDomain(hostname, domain)
      );
    } catch {
      return false;
    }
  }

  verify(url: string | URL) {
    try {
      if (typeof url === 'string') {
        url = new URL(url);
      }
      if (!['http:', 'https:'].includes(url.protocol)) return false;
      if (!url.hostname) return false;
      return true;
    } catch {
      return false;
    }
  }

  private convertHostToOrigin(host: string) {
    return [
      this.config.server.https ? 'https' : 'http',
      '://',
      host,
      host === 'localhost' || isIP(host) ? `:${this.config.server.port}` : '',
    ].join('');
  }
}
